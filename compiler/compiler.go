package main

import (
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"

	"golang.org/x/net/html"
)

// compile is the heart of our AOT compiler. It reads an HTML file,
// parses it, and generates a corresponding Go file using the vdom package.
func compile(inPath, outPath string) error {
	// Step 1: Read the source HTML file from disk.
	htmlContent, err := os.ReadFile(inPath)
	if err != nil {
		return fmt.Errorf("could not read input file %s: %w", inPath, err)
	}

	// Step 2: Parse the HTML content into a walkable node tree.
	doc, err := html.Parse(strings.NewReader(string(htmlContent)))
	if err != nil {
		return fmt.Errorf("failed to parse HTML: %w", err)
	}

	// Step 3: Find the <body> tag, which contains the content we want to compile.
	bodyNode := findBody(doc)
	if bodyNode == nil {
		return fmt.Errorf("could not find <body> tag in the input HTML")
	}

	// Step 4: Find the first actual HTML element inside the body.
	// This will be the root of our component's VNode tree.
	rootElement := findFirstElementChild(bodyNode)
	if rootElement == nil {
		return fmt.Errorf("no element found inside <body> tag to compile")
	}

	// Step 5: Recursively generate the Go code for the vdom structure.
	generatedCode := generateNodeCode(rootElement)

	// Step 6: Assemble the complete Go source file as a string.
	template :=
		`// Code generated by the nojs AOT compiler. DO NOT EDIT.
		package main

		import (
			"github.com/vcrobe/nojs/vdom"
		)

		// render builds and returns the VNode structure for the compiled HTML.
		func render() *vdom.VNode {
			return %s
		}
		`

	source := fmt.Sprintf(template, generatedCode)

	// Step 7: Format the generated Go code to make it clean and readable.
	formattedSource, err := format.Source([]byte(source))

	if err != nil {
		// If formatting fails, we can still write the unformatted code, but we should warn the user.
		log.Fatalln("could not format generated code:", err)
	}

	// Step 8: Write the final, formatted Go code to the output file.
	return os.WriteFile(outPath, formattedSource, 0644)
}

// generateNodeCode recursively walks the HTML tree and generates Go vdom calls.
func generateNodeCode(n *html.Node) string {
	// Handle HTML elements (like <div>, <p>, etc.)
	if n.Type == html.ElementNode {
		switch n.Data {
		case "div":
			var childrenCode []string
			// Recursively generate code for all child nodes.
			for c := n.FirstChild; c != nil; c = c.NextSibling {
				childCode := generateNodeCode(c)
				if childCode != "" {
					childrenCode = append(childrenCode, childCode)
				}
			}
			// Assemble the vdom.Div call with its children.
			return fmt.Sprintf("vdom.Div(nil, %s)", strings.Join(childrenCode, ", "))

		case "p":
			// For paragraphs, find the text content.
			textContent := ""
			for c := n.FirstChild; c != nil; c = c.NextSibling {
				if c.Type == html.TextNode {
					textContent = strings.TrimSpace(c.Data)
					break // Use the first text node we find.
				}
			}
			return fmt.Sprintf("vdom.Paragraph(\"%s\", nil)", textContent)

		default:
			// For now, we ignore any tags we don't recognize.
			return ""
		}
	}

	// We ignore comments, doctypes, etc.
	return ""
}

// findBody is a helper function to traverse the tree and find the <body> node.
func findBody(n *html.Node) *html.Node {
	if n.Type == html.ElementNode && n.Data == "body" {
		return n
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if result := findBody(c); result != nil {
			return result
		}
	}

	return nil
}

// findFirstElementChild finds the first child of a node that is an actual element,
// skipping over text nodes (like whitespace).
func findFirstElementChild(n *html.Node) *html.Node {
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if c.Type == html.ElementNode {
			return c
		}
	}

	return nil
}

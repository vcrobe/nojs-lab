package compiler

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/net/html"
)

// compileComponentTemplate reads a .gt.html template, parses it, generates Go code,
// formats it, and writes the result to a .generated.go file next to the template.
func compileComponentTemplate(comp componentInfo, componentMap map[string]componentInfo, inDir string, opts compileOptions) error {
	htmlContent, err := os.ReadFile(comp.Path)
	if err != nil {
		return fmt.Errorf("failed to read template file %s: %w", comp.Path, err)
	}
	htmlString := string(htmlContent)

	// Preprocess conditional blocks with validation
	htmlString, err = preprocessConditionals(htmlString, comp.Path)
	if err != nil {
		return err // Error message already includes template path and details
	}

	// Preprocess for-loop blocks with validation
	htmlString, err = preprocessFor(htmlString, comp.Path)
	if err != nil {
		return err // Error message already includes template path and details
	}

	doc, err := html.Parse(strings.NewReader(htmlString))
	if err != nil {
		return fmt.Errorf("failed to parse HTML: %w", err)
	}
	bodyNode := findBody(doc)
	if bodyNode == nil {
		return fmt.Errorf("could not find <body> tag")
	}

	rootElement := findFirstElementChild(bodyNode)
	if rootElement == nil {
		return fmt.Errorf("no element found inside <body> tag to compile")
	}

	// Collect components used from other packages
	usedPackages := collectUsedComponents(rootElement, componentMap, comp)

	// Initialize template-wide component counter so every RenderChild key is unique
	// regardless of where in the tree the component appears. Using sibling-position
	// (childCount) would assign the same key to components at the same depth across
	// different parent containers (e.g. multiple RouterLinks each being the 3rd child
	// of their respective parent divs all get "RouterLink_3").
	opts.ComponentCounter = make(map[string]int)

	// Generate code for a single root node
	generatedCode := generateNodeCode(rootElement, "c", componentMap, comp, htmlString, opts, nil)

	// Generate the ApplyProps method body
	applyPropsBody := generateApplyPropsBody(comp)

	// Build additional imports for cross-package components
	var additionalImports strings.Builder
	if len(usedPackages) > 0 {
		additionalImports.WriteString("\n")
		for _, importPath := range usedPackages {
			additionalImports.WriteString(fmt.Sprintf("\t\"%s\"\n", importPath))
		}
	}

	// NOTE: NO build tags! This file must be available to both WASM and test builds.
	// The core types (vdom.VNode, runtime.Renderer, runtime.Component) are now
	// available without build tags, allowing this generated code to work everywhere.
	template := `// Code generated by the nojs AOT compiler. DO NOT EDIT.
package %[2]s

import (
	"fmt"
	"strconv" // Added for type conversions

	"github.com/ForgeLogic/nojs/console"
	"github.com/ForgeLogic/nojs/events"
	"github.com/ForgeLogic/nojs/runtime"
	"github.com/ForgeLogic/nojs/vdom"%[5]s
)

// ApplyProps copies props from source to the receiver, preserving internal state.
// This method is generated automatically by the compiler.
func (c *%[1]s) ApplyProps(source runtime.Component) {
	src, ok := source.(*%[1]s)
	if !ok {
		// Type mismatch - this should never happen in normal operation
		return
	}
	_ = src // Suppress unused variable warning if no props to copy
%[4]s
}

// Render generates the VNode tree for the %[1]s component.
func (c *%[1]s) Render(r runtime.Renderer) *vdom.VNode {
	_ = strconv.Itoa // Suppress unused import error if no props are converted
	_ = fmt.Sprintf  // Suppress unused import error if no bindings are used
	_ = console.Log  // Suppress unused import error if no loops use dev warnings
	_ = events.AdaptNoArgEvent // Suppress unused import error if no event handlers are used

	return %[3]s
}
`

	source := fmt.Sprintf(template, comp.PascalName, comp.PackageName, generatedCode, applyPropsBody, additionalImports.String())

	// Format the generated source code
	formattedSource, err := format.Source([]byte(source))
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	outFileName := fmt.Sprintf("%s.generated.go", comp.PascalName)

	// Generate file in the same directory as the template
	templateDir := filepath.Dir(comp.Path)
	outFilePath := filepath.Join(templateDir, outFileName)
	return os.WriteFile(outFilePath, formattedSource, 0644)
}

// generateApplyPropsBody generates the body of the ApplyProps method.
// It creates assignment statements to copy all props from source to receiver.
func generateApplyPropsBody(comp componentInfo) string {
	if len(comp.Schema.Props) == 0 && comp.Schema.Slot == nil {
		return "\t// No props to copy"
	}

	var assignments []string

	// Copy regular props (sorted by name for consistent output)
	propNames := make([]string, 0, len(comp.Schema.Props))
	for propName := range comp.Schema.Props {
		propNames = append(propNames, propName)
	}
	// Sort for deterministic output
	for i := 0; i < len(propNames); i++ {
		for j := i + 1; j < len(propNames); j++ {
			if propNames[i] > propNames[j] {
				propNames[i], propNames[j] = propNames[j], propNames[i]
			}
		}
	}

	for _, propName := range propNames {
		prop := comp.Schema.Props[propName]
		assignments = append(assignments,
			fmt.Sprintf("\tc.%s = src.%s", prop.Name, prop.Name))
	}

	// Copy slot content if exists
	if comp.Schema.Slot != nil {
		assignments = append(assignments,
			fmt.Sprintf("\tc.%s = src.%s", comp.Schema.Slot.Name, comp.Schema.Slot.Name))
	}

	return strings.Join(assignments, "\n")
}
